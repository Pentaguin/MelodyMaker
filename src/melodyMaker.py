'''
Requirements: Generate a song by combining building blocks.

Design:
    Each song has atleast 2 building blocks (bb) and each bb has notes.
    Create the bb first. Then create the song by combining the bb.

    Combine already existing bb into a new song:
    Randomly select bb WAV files. 
    Then let the user choose them. After that the user can swap the building block orders.
    When swapping is done. Pick the selected bb WAV files and copy them into a new WAV file, but with another name. 
    Also Create the new song by combining the bb WAV files

Test during development:
    - Print bb notes
    - Write bb data to a pickle file and read it
    - Create and play WAV files from song and bb
    - Create a new song by combining already existing bb 
    - Mutate a bb and overwrite the old bb pickle and WAV file

End test:
    - Test if the program still work without the database directory
    - Test if the program still work when the database directory still exist
    - Test if new songs can be generated by using this program
'''

from dataStorage import DataStorage
from song import Song
import os
import glob as gl
import random as rd
import itertools

class MelodyMaker:
    def getUserPreference(self):
        self.newDatabase = True
        self.db = DataStorage()
        self.databasePath = str(self.db.databasePath)

        if(self.db.checkIfDatabaseDirectoryExist()): 
            print("\nDatabase already exist. Do you want to start over again or do you want to continue?")

            while(True):
                chosenValue = self.askValue("[Enter 0 for continue | Enter 1 for restart] ", int)

                if(chosenValue == 1): # Remove old database.
                    self.newDatabase = True
                    self.db.removeDatabaseDirectory()
                    break
                elif(chosenValue == 0):
                    self.newDatabase = False
                    break
        
        if(self.newDatabase):
            self.songAmount = 0
            self.buildingBlockAmount = 0

            while (self.songAmount < 1 or self.buildingBlockAmount < 2):
                self.songAmount = self.askValue("\nHow many songs? [Atleast 1] ", int)
                self.buildingBlockAmount = self.askValue("How many building blocks per song? [Atleast 2] ", int)

        else:
            songData = self.db.getPickleFileData(self.databasePath + "\SongData")
            self.songAmount = songData[0]
            self.buildingBlockAmount = songData[1]
        
    def askValue(self,message, desired_type):
        while True:
            try:
                return desired_type(input(message))
            except ValueError:
                print("cannot convert input to", str(desired_type))

    def start(self):
        if(self.newDatabase):
            self.db.createDatabaseDirectory()
            self.db.createPickleFile(self.databasePath + "\SongData", (self.songAmount,self.buildingBlockAmount)) # Write the data from the songs to a pickle file
            self.generateSongs()

        while(True):
            chosenValue = self.askValue("\nDo you want to combine building blocks? [Enter 0 for No | Enter 1 for Yes] ", int)

            if(chosenValue == 1):
                self.selectRandomWAVFiles()
            elif(chosenValue == 0):
                break

    # Start by creating songs and building blocks.
    def generateSongs(self):
        print("\n---Generating songs---\n")
        
        for songIndex in range(self.songAmount):
            song = Song()
            song.createRandomBuildingBlock(self.buildingBlockAmount) 
            combinedSong = song.createSong() 
            self.db.createWAVfile(self.databasePath + f"\Song{songIndex}.wav", combinedSong) # Write the song to a WAV file.

            print(f"Now playing song {songIndex}")
            self.db.playWAV(self.databasePath + f"\Song{songIndex}.wav") # Play the WAV file from the song.

            # Write the building blocks to WAV and pickle files.
            for buildingBlockIndex in range(len(song.buildingBlocks)):
                self.db.createWAVfile(self.databasePath + f"\Song{songIndex}bb{buildingBlockIndex}.wav", song.buildingBlocks[buildingBlockIndex].notes)
                self.db.createPickleFile(self.databasePath + f"\Song{songIndex}bb{buildingBlockIndex}", song.buildingBlocks[buildingBlockIndex].notes)
            
        print("\nSongs and building block generation finished")

    # Choose random WAV files from building blocks
    def selectRandomWAVFiles(self): 
        print("\n---Combining---\n")
        
        # Buildingblock amount x 2 will be given as options
        givenSize = 2 * self.buildingBlockAmount
        buildingBlockWAVFileOptions = []

        # Randomly select the WAV files with bb (BuildingBlock) in its name.
        for i in range(givenSize): 
            buildingBlockWAVFileOptions.append(rd.choice(gl.glob(self.databasePath + '\*bb*.wav')))

        print(f"Random building blocks are given. Choose the {self.buildingBlockAmount} building blocks from the {givenSize} given options to combine into a new song.")

        # Listening to the WAV files from the building blocks
        while(True):
            print("Enter the number from the building block you want to listen to.")
            print(f"Given building blocks are number 1 to {givenSize}.")
            chosenNumber = self.askValue("If you want to stop listening and want to start selecting. [Enter 0] ", int)

            if(chosenNumber == 0): # Quit loop and continue selecting
                break

            if(chosenNumber < 0 or chosenNumber > givenSize):
                print("Number does not exist\n")
            else: 
                print(f"Now listening to building block number {chosenNumber}\n")
                self.db.playWAV(buildingBlockWAVFileOptions[chosenNumber - 1]) # List start with 0

        selectedNumbers = self.getSelectedBuildingBlockNumbers(givenSize) 
        selectedOrder = self.getSortedBuildingBlockNumbers(selectedNumbers)
        self.combineBuildingBlocksIntoSong(selectedOrder, buildingBlockWAVFileOptions)

    # Select the building block index
    def getSelectedBuildingBlockNumbers(self, givenSize):
        selectedNumbers = [] 
        amountOfFilesChosen = 0
        currentIndex = 1

        while(True):
            chosenNumber = self.askValue(f"\nDo you want to select building block number {currentIndex}. [Enter 1 for Yes | Enter 0 for No] ", int)
                
            if(chosenNumber == 1): # Building block selected
                print(f"Building block number {currentIndex} selected.")
                amountOfFilesChosen += 1
                selectedNumbers.append(currentIndex)

                if(amountOfFilesChosen == self.buildingBlockAmount): # File selection is done
                    print("\n---Building block selection is finished---\n")
                    break
                elif(amountOfFilesChosen < self.buildingBlockAmount and currentIndex == givenSize): 
                    print(f"But already reached the end of the list, but only {amountOfFilesChosen} out of the {self.buildingBlockAmount} has been selected. Start over again")
                    currentIndex = 1
                    amountOfFilesChosen = 0
                    selectedNumbers[:] = [] 
                else: 
                    currentIndex += 1

            elif(chosenNumber == 0): # Building block not selected
                if(amountOfFilesChosen != self.buildingBlockAmount and currentIndex == givenSize): # List is at the end
                    print(f"\nAlready reached the end of the list, but only {amountOfFilesChosen} out of the {self.buildingBlockAmount} has been selected. Start over again")
                    currentIndex = 1
                    amountOfFilesChosen = 0
                    selectedNumbers[:] = []
                else: 
                    currentIndex += 1
        
        return selectedNumbers

    # Swap the building block from a song in the order you want.
    def getSortedBuildingBlockNumbers(self, selectedNumbers): 
        orderList =  list(itertools.permutations(selectedNumbers))
        selectedOrder = []

        for index, order in enumerate(orderList):
            print(index + 1, order)

        while (True):
            chosenNumber = self.askValue("Enter the number from the order you want. ", int)
            if (chosenNumber > 0 and chosenNumber < len(orderList) + 1): # Number is between the given options.
                selectedOrder = orderList[chosenNumber - 1]
                break

        return selectedOrder
        
    def combineBuildingBlocksIntoSong(self, selectedOrder, buildingBlockWAVFileOptions):
        temporaryList = [x-1 for x in selectedOrder] # Every number - 1 to make the index start at 0 again.
        selectedWAVFiles = []
        newSong = []

        print("\nNow generating the new combined song")

        # Add the selected WAV files from all the given options to the selectedWAVFiles list.
        for buildingBlockIndex in range(len(temporaryList)):
            selectedWAVFiles.append(buildingBlockWAVFileOptions[temporaryList[buildingBlockIndex]])
            buildingBlockPickleData = self.db.getPickleFileData(selectedWAVFiles[buildingBlockIndex][:-4]) # Remove the last 4 chars, which is .wav to get the pickle file.
            newSong += buildingBlockPickleData
            self.db.createWAVfile(self.databasePath + f"\Song{self.songAmount}bb{buildingBlockIndex}.wav", buildingBlockPickleData)
            self.db.createPickleFile(self.databasePath + f"\Song{self.songAmount}bb{buildingBlockIndex}", buildingBlockPickleData)

        self.db.createWAVfile(self.databasePath + f"\Song{self.songAmount}.wav", newSong) # Write the song to a WAV file
        self.db.createPickleFile(self.databasePath + "\SongData", (self.songAmount + 1, self.buildingBlockAmount)) # Update the SongData file. +1 because songAmount starts with 1 instead of 0
        print("New song is complete. Now playing new song.")
        self.db.playWAV(self.databasePath + f"\Song{self.songAmount}.wav") 
        self.mutate()

    # Check if a building block will mutate or not.
    def mutate(self): 
        mutated = False
        randomWAVFile = rd.choice(gl.glob(self.databasePath + '\*bb*.wav')) # Randomly choose a building block WAV file to mutate
        pickleFileData = self.db.getPickleFileData(randomWAVFile[:-4]) # -4 to remove .wav and extract the pickle data
        
        for i in range(len(pickleFileData)):
            if(rd.random() < 0.25): # 25% chance to mutate  
                if(not mutated):
                    print(f"\n{randomWAVFile} is mutated")
                    print("\nBefore mutation")
                    print(pickleFileData)
                    self.db.playWAV(randomWAVFile)

                pickleFileData[i] = (rd.choice(['c','d','e','f','g''a','b','c#','f#','g#','ab','bb']), 8) 
                mutated = True
        
        if(mutated): # Overwrite the old building block WAV file with the mutated one.
            print("After mutation")
            print(pickleFileData)    
            temporaryWAVFile = randomWAVFile

            os.remove(randomWAVFile)
            self.db.createWAVfile(temporaryWAVFile, pickleFileData) 
            self.db.createPickleFile(temporaryWAVFile[:-4], pickleFileData)
            self.db.playWAV(temporaryWAVFile)
            
melodyMaker = MelodyMaker()
melodyMaker.getUserPreference()
melodyMaker.start()